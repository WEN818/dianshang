# 中小型电商系统实验报告

**学号**：202230443019  
**姓名**：温恺曼  
**GitHub源码地址**：[https://github.com/WEN818/dianshang](https://github.com/WEN818/dianshang)  
**应用部署地址**：[http://114.132.150.59:8080/](http://114.132.150.59:8080/)

---

## 1. 系统设计

### 1.1 系统整体架构

本系统采用经典的三层架构设计，结合Spring Boot框架实现了一个功能完整的中小型电商系统。系统整体架构如下：

```
┌─────────────────────────────────────────────────────────┐
│                     前端展示层                            │
│  (Thymeleaf模板: products.html, cart.html, orders.html) │
└────────────────────┬────────────────────────────────────┘
                     │ HTTP请求/响应
┌────────────────────▼────────────────────────────────────┐
│                   控制器层 (Controller)                   │
│  ViewController | ProductController | OrderController    │
│  AdminController | AuthController                        │
└────────────────────┬────────────────────────────────────┘
                     │ 业务调用
┌────────────────────▼────────────────────────────────────┐
│                   业务逻辑层 (Service)                    │
│  ProductService | CartService | OrderService             │
│  EmailService | ActivityLogService                       │
└────────────────────┬────────────────────────────────────┘
                     │ 数据访问
┌────────────────────▼────────────────────────────────────┐
│                   数据访问层 (Repository)                 │
│  ProductRepository | CartItemRepository | OrderRepository│
└────────────────────┬────────────────────────────────────┘
                     │ SQL查询
┌────────────────────▼────────────────────────────────────┐
│                   数据持久层 (MySQL)                      │
│  users | product | cart_item | orders | order_item       │
└─────────────────────────────────────────────────────────┘
```

### 1.2 技术架构说明

- **前端技术**：Thymeleaf模板引擎，实现服务端渲染
- **后端框架**：Spring Boot 4.0.0，提供依赖注入和自动配置
- **安全框架**：Spring Security，实现用户认证和权限控制
- **数据持久化**：Spring Data JPA + Hibernate，简化数据库操作
- **容器化部署**：Docker + Docker Compose，实现一键部署
- **邮件服务**：Spring Boot Mail，实现订单邮件通知

### 1.3 各模块详细介绍

#### 1.3.1 用户认证模块

**功能**：用户注册、登录、注销账户

**核心组件**：
- `UserAccount` 实体：存储用户信息（用户名、密码、角色、邮箱、启用状态）
- `AuthController`：处理注册和账户注销请求
- `CustomUserDetailsService`：实现Spring Security的用户加载逻辑
- `SecurityConfig`：配置安全策略、登录/登出处理、权限控制

**关键特性**：
- 密码使用BCrypt加密存储
- 支持账户启用/停用状态管理
- 会话管理和单点登录控制
- 区分管理员和普通用户角色

#### 1.3.2 商品管理模块

**功能**：商品的增删改查、软删除

**核心组件**：
- `Product` 实体：商品信息（名称、描述、价格、库存、删除标记）
- `ProductRepository`：提供商品数据访问方法，支持软删除查询
- `ProductService`：商品业务逻辑处理
- `ProductController`：商品API接口（管理员权限）

**关键特性**：
- 软删除机制：删除商品时只标记为已删除，保留历史订单数据
- 商品列表自动过滤已删除商品
- 管理员权限控制

#### 1.3.3 购物车模块

**功能**：添加商品、更新数量、删除商品、自动合并重复商品

**核心组件**：
- `CartItem` 实体：购物车项（用户ID、商品、数量）
- `CartItemRepository`：提供购物车数据访问，支持按用户和商品查询
- `CartService`：购物车业务逻辑，实现重复商品自动合并

**关键特性**：
- 重复商品自动合并：添加相同商品时累加数量而非创建新项
- 购物车与用户自动绑定
- 支持数量更新和删除操作

#### 1.3.4 订单管理模块

**功能**：创建订单、支付、取消、发货、完成订单

**核心组件**：
- `Order` 实体：订单信息（订单号、用户、金额、状态、收货信息）
- `OrderItem` 实体：订单项（商品、数量、价格、小计）
- `OrderRepository`：订单数据访问
- `OrderService`：订单业务逻辑（创建、支付、发货、完成）
- `OrderController`：订单API接口
- `OrderStatusUtil`：订单状态显示工具类

**订单状态流转**：
```
待支付 (PENDING_PAYMENT) 
  ↓ 支付
已支付 (PAID) 
  ↓ 发货
已发货 (SHIPPED) 
  ↓ 完成
已完成 (COMPLETED)
```

**关键特性**：
- 订单号自动生成（时间戳+UUID）
- 订单状态管理
- 支付后自动发送确认邮件
- 发货后自动发送通知邮件
- 订单项与订单关联保存

#### 1.3.5 管理员模块

**功能**：数据概览、订单管理、客户管理、商品管理

**核心组件**：
- `AdminController`：管理员API接口（需要ADMIN角色）
- `ViewController`：管理员页面路由
- 管理后台页面：dashboard、orders、customers、products

**关键特性**：
- 销售统计（总订单数、已支付订单、总销售额）
- 订单管理（查看、发货、完成）
- 客户管理（查看列表、详情、启用/停用账户）
- 商品管理（增删改查）
- 权限控制（仅管理员可访问）

#### 1.3.6 邮件服务模块

**功能**：发送订单确认邮件、发货通知邮件

**核心组件**：
- `EmailService`：邮件发送服务
- 使用QQ邮箱SMTP服务
- 支持HTML格式邮件

**关键特性**：
- 订单支付后自动发送确认邮件
- 订单发货后自动发送通知邮件
- 邮件包含订单详细信息

#### 1.3.7 活动日志模块

**功能**：记录用户关键操作日志

**核心组件**：
- `UserActivityLog` 实体：活动日志（用户ID、活动类型、描述、时间）
- `ActivityLogService`：日志记录服务
- 记录注册、登录、购物车操作、订单操作等

**关键特性**：
- 异步日志记录，不影响主业务流程
- 支持多种活动类型
- 便于系统审计和问题追踪

---

## 2. 代码实现

### 2.1 实现过程

#### 2.1.1 项目初始化
1. 使用Spring Initializr创建Spring Boot项目
2. 添加必要依赖：Spring Web、Spring Data JPA、MySQL Driver、Spring Security、Thymeleaf、Spring Boot Mail
3. 配置数据库连接和JPA设置
4. 创建基础包结构（entity、repository、service、controller）

#### 2.1.2 实体类设计
按照数据库设计创建实体类，使用JPA注解进行ORM映射：
- 使用`@Entity`标记实体类
- 使用`@Id`和`@GeneratedValue`定义主键
- 使用`@OneToMany`、`@ManyToOne`定义关联关系
- 使用`@Enumerated`处理枚举类型

#### 2.1.3 数据访问层实现
继承`JpaRepository`接口，利用Spring Data JPA的自动实现：
- 使用方法命名约定自动生成查询
- 使用`@Query`注解编写自定义查询
- 实现软删除查询方法

#### 2.1.4 业务逻辑层实现
在Service层实现核心业务逻辑：
- 使用`@Transactional`保证数据一致性
- 实现异常处理和参数验证
- 集成邮件服务和日志服务

#### 2.1.5 控制器层实现
- `ViewController`：处理页面路由，返回Thymeleaf模板
- REST API控制器：处理JSON请求，返回JSON响应
- 使用`@PreAuthorize`实现方法级权限控制

#### 2.1.6 安全配置
配置Spring Security：
- 定义URL访问规则
- 配置登录/登出处理
- 实现会话管理
- 配置CSRF保护（开发环境禁用）

#### 2.1.7 前端页面开发
使用Thymeleaf模板引擎开发前端页面：
- 使用Thymeleaf表达式绑定数据
- 实现条件渲染和循环渲染
- 使用JavaScript处理交互逻辑

### 2.2 关键代码实现

#### 2.2.1 购物车重复商品合并功能

**文件**：`CartService.java`

```java
@Transactional
public CartItem addToCart(String userId, Long productId, Integer quantity) {
    // 1. 验证商品是否存在且未删除
    Product product = productRepository.findActiveById(productId)
            .orElseThrow(() -> new IllegalArgumentException("商品不存在"));
    
    if (product.getDeleted() != null && product.getDeleted()) {
        throw new IllegalArgumentException("商品已下架");
    }

    // 2. 检查购物车中是否已存在该商品
    Optional<CartItem> existingItem = cartItemRepository.findByUserIdAndProductId(userId, productId);
    
    if (existingItem.isPresent()) {
        // 3. 如果已存在，更新数量（累加）
        CartItem cartItem = existingItem.get();
        cartItem.setQuantity(cartItem.getQuantity() + quantity);
        return cartItemRepository.save(cartItem);
    } else {
        // 4. 如果不存在，创建新的购物车项
        CartItem cartItem = new CartItem();
        cartItem.setUserId(userId);
        cartItem.setProduct(product);
        cartItem.setQuantity(quantity);
        return cartItemRepository.save(cartItem);
    }
}
```

**说明**：
- 使用`@Transactional`保证数据一致性
- 通过`findByUserIdAndProductId`查询是否已存在相同商品
- 存在则累加数量，不存在则创建新项
- 实现了重复商品的自动合并功能

#### 2.2.2 订单创建和支付流程

**文件**：`OrderService.java`

```java
@Transactional
public Order createOrder(String userId, String receiverName, String receiverPhone, 
                       String shippingAddress, String userEmail, List<CartItem> cartItems) {
    // 1. 验证购物车不为空
    if (cartItems == null || cartItems.isEmpty()) {
        throw new IllegalArgumentException("购物车为空");
    }

    // 2. 创建订单对象
    Order order = new Order();
    // 生成唯一订单号：时间戳 + UUID
    order.setOrderNumber("ORD" + System.currentTimeMillis() + 
                        UUID.randomUUID().toString().substring(0, 8).toUpperCase());
    order.setUserId(userId);
    order.setReceiverName(receiverName);
    order.setReceiverPhone(receiverPhone);
    order.setShippingAddress(shippingAddress);
    order.setUserEmail(userEmail);
    order.setStatus(Order.OrderStatus.PENDING_PAYMENT); // 初始状态：待支付

    // 3. 遍历购物车项，创建订单项
    double totalAmount = 0.0;
    for (CartItem cartItem : cartItems) {
        Product product = cartItem.getProduct();
        // 跳过已删除的商品
        if (product.getDeleted() != null && product.getDeleted()) {
            continue;
        }

        OrderItem orderItem = new OrderItem();
        orderItem.setOrder(order);
        orderItem.setProduct(product);
        orderItem.setQuantity(cartItem.getQuantity());
        orderItem.setPrice(product.getPrice());
        orderItem.setSubtotal(product.getPrice() * cartItem.getQuantity());
        
        totalAmount += orderItem.getSubtotal();
        order.getItems().add(orderItem);
    }

    // 4. 设置订单总金额并保存
    order.setTotalAmount(totalAmount);
    Order savedOrder = orderRepository.save(order);

    // 5. 保存订单项
    for (OrderItem item : savedOrder.getItems()) {
        item.setOrder(savedOrder);
        orderItemRepository.save(item);
    }

    // 6. 清空购物车
    cartItemRepository.deleteAll(cartItems);

    return savedOrder;
}

@Transactional
public Order payOrder(Long orderId) {
    // 1. 查询订单
    Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new IllegalArgumentException("订单不存在"));

    // 2. 验证订单状态
    if (order.getStatus() != Order.OrderStatus.PENDING_PAYMENT) {
        throw new IllegalStateException("订单状态不正确，无法支付");
    }

    // 3. 更新订单状态和支付时间
    order.setStatus(Order.OrderStatus.PAID);
    order.setPaidAt(LocalDateTime.now());
    Order savedOrder = orderRepository.save(order);

    // 4. 发送订单确认邮件
    emailService.sendOrderConfirmationEmail(savedOrder);

    return savedOrder;
}
```

**说明**：
- 订单创建时自动生成唯一订单号
- 计算订单总金额并保存订单项
- 支付后更新状态并发送确认邮件
- 使用事务保证数据一致性

#### 2.2.3 Spring Security安全配置

**文件**：`SecurityConfig.java`

```java
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        // 禁用CSRF（开发环境，生产环境应启用）
        .csrf(AbstractHttpConfigurer::disable)
        // 配置URL访问规则
        .authorizeHttpRequests(auth -> auth
            // 公开访问的路径
            .requestMatchers("/", "/register", "/register/page", "/login", "/logout", 
                           "/css/**", "/js/**").permitAll()
            .requestMatchers("/products", "/products/**").permitAll()
            // 管理员路径需要ADMIN角色
            .requestMatchers("/api/admin/**").hasRole("ADMIN")
            .requestMatchers("/admin/**").hasRole("ADMIN")
            // 其他路径需要登录
            .anyRequest().authenticated()
        )
        // 配置表单登录
        .formLogin(form -> form
            .loginPage("/login")
            .successHandler(loginSuccessHandler) // 使用自定义登录成功处理器
            .defaultSuccessUrl("/products/page", true)
            .permitAll()
        )
        // 配置登出
        .logout(logout -> logout
            .logoutUrl("/logout")
            .logoutSuccessUrl("/login?logout=true")
            .invalidateHttpSession(true)
            .clearAuthentication(true)
            .deleteCookies("JSESSIONID")
            .permitAll()
        )
        // 配置会话管理
        .sessionManagement(session -> session
            .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
            .maximumSessions(1) // 单点登录
            .maxSessionsPreventsLogin(false)
            .expiredUrl("/login?expired=true")
        );

    return http.build();
}
```

**说明**：
- 配置了URL访问权限规则
- 实现了基于角色的访问控制（RBAC）
- 配置了会话管理和单点登录
- 使用自定义登录成功处理器记录日志

#### 2.2.4 邮件发送服务

**文件**：`EmailService.java`

```java
@Service
public class EmailService {

    private final JavaMailSender mailSender;
    
    @Value("${spring.mail.from}")
    private String fromEmail;

    public EmailService(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    /**
     * 发送订单确认邮件
     */
    public void sendOrderConfirmationEmail(Order order) {
        // 检查用户是否提供了邮箱
        if (order.getUserEmail() == null || order.getUserEmail().trim().isEmpty()) {
            System.out.println("用户未提供邮箱，跳过邮件发送");
            return;
        }

        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setFrom(fromEmail);
            message.setTo(order.getUserEmail());
            message.setSubject("订单确认 - " + order.getOrderNumber());
            
            // 构建邮件内容
            StringBuilder content = new StringBuilder();
            content.append("尊敬的客户，\n\n");
            content.append("您的订单已成功创建！\n\n");
            content.append("订单号：").append(order.getOrderNumber()).append("\n");
            content.append("订单金额：¥").append(String.format("%.2f", order.getTotalAmount())).append("\n");
            content.append("订单状态：").append(getStatusText(order.getStatus())).append("\n\n");
            content.append("请尽快完成支付。\n\n");
            content.append("感谢您的购买！");
            
            message.setText(content.toString());
            mailSender.send(message);
            System.out.println("订单确认邮件已发送至：" + order.getUserEmail());
        } catch (Exception e) {
            System.err.println("发送邮件失败：" + e.getMessage());
            // 邮件发送失败不影响订单创建
        }
    }

    /**
     * 发送发货通知邮件
     */
    public void sendShippingNotificationEmail(Order order) {
        if (order.getUserEmail() == null || order.getUserEmail().trim().isEmpty()) {
            return;
        }

        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setFrom(fromEmail);
            message.setTo(order.getUserEmail());
            message.setSubject("订单已发货 - " + order.getOrderNumber());
            
            StringBuilder content = new StringBuilder();
            content.append("尊敬的客户，\n\n");
            content.append("您的订单已发货！\n\n");
            content.append("订单号：").append(order.getOrderNumber()).append("\n");
            content.append("收货人：").append(order.getReceiverName()).append("\n");
            content.append("收货地址：").append(order.getShippingAddress()).append("\n\n");
            content.append("请注意查收。\n\n");
            content.append("感谢您的购买！");
            
            message.setText(content.toString());
            mailSender.send(message);
            System.out.println("发货通知邮件已发送至：" + order.getUserEmail());
        } catch (Exception e) {
            System.err.println("发送邮件失败：" + e.getMessage());
        }
    }
}
```

**说明**：
- 使用Spring Boot Mail发送邮件
- 支持订单确认和发货通知两种邮件
- 邮件发送失败不影响主业务流程
- 使用QQ邮箱SMTP服务

### 2.3 GitHub代码地址

**仓库地址**：[https://github.com/WEN818/dianshang](https://github.com/WEN818/dianshang)

**主要代码文件说明**：

1. **实体类** (`entity/`)
   - `Product.java` - 商品实体，包含软删除标记
   - `CartItem.java` - 购物车项实体
   - `Order.java` - 订单实体，包含订单状态枚举
   - `OrderItem.java` - 订单项实体
   - `UserAccount.java` - 用户账户实体，包含角色和启用状态
   - `UserActivityLog.java` - 用户活动日志实体

2. **数据访问层** (`repository/`)
   - `ProductRepository.java` - 商品数据访问，支持软删除查询
   - `CartItemRepository.java` - 购物车数据访问，支持按用户和商品查询
   - `OrderRepository.java` - 订单数据访问
   - `UserAccountRepository.java` - 用户数据访问

3. **业务逻辑层** (`service/`)
   - `ProductService.java` - 商品业务逻辑，实现软删除
   - `CartService.java` - 购物车业务逻辑，实现重复商品合并
   - `OrderService.java` - 订单业务逻辑，实现订单状态流转
   - `EmailService.java` - 邮件发送服务
   - `ActivityLogService.java` - 活动日志服务

4. **控制器层** (`controller/`)
   - `ViewController.java` - 页面视图控制器，处理所有页面路由
   - `ProductController.java` - 商品API控制器
   - `OrderController.java` - 订单API控制器
   - `AdminController.java` - 管理员API控制器
   - `AuthController.java` - 认证控制器

5. **配置类** (`config/`)
   - `SecurityConfig.java` - Spring Security安全配置
   - `LoginSuccessHandler.java` - 登录成功处理器
   - `SampleDataConfig.java` - 初始化数据配置

6. **前端模板** (`resources/templates/`)
   - `products.html` - 商品列表页面
   - `cart.html` - 购物车页面
   - `orders.html` - 订单列表页面
   - `order-detail.html` - 订单详情页面
   - `admin-dashboard.html` - 管理后台首页
   - `admin-orders.html` - 订单管理页面
   - `admin-customers.html` - 客户管理页面
   - `admin-products.html` - 商品管理页面

---

## 3. 功能测试

### 3.1 测试环境

- **测试地址**：http://114.132.150.59:8080/
- **测试浏览器**：Chrome、Edge
- **测试账号**：
  - 管理员：`admin` / `admin123`
  - 普通用户：可通过注册页面创建

### 3.2 测试方法

#### 3.2.1 用户注册测试

**测试步骤**：
1. 访问 http://114.132.150.59:8080/register/page
2. 填写注册信息（用户名、密码、邮箱）
3. 点击"注册"按钮
4. 验证注册是否成功

**预期结果**：
- 注册成功，跳转到登录页面
- 数据库中新增用户记录
- 密码已加密存储
- 用户状态为"启用"

**测试结果**：✅ 通过

#### 3.2.2 用户登录测试

**测试步骤**：
1. 访问 http://114.132.150.59:8080/login
2. 输入用户名和密码
3. 点击"登录"按钮
4. 验证登录是否成功

**预期结果**：
- 登录成功，跳转到商品列表页面
- 页面显示当前用户名
- 显示购物车、订单、管理后台等按钮

**测试结果**：✅ 通过

#### 3.2.3 商品浏览测试

**测试步骤**：
1. 登录后访问商品列表页面
2. 查看商品信息（名称、描述、价格）
3. 测试添加商品到购物车

**预期结果**：
- 商品列表正常显示
- 可以正常添加商品到购物车
- 购物车数量正确更新

**测试结果**：✅ 通过

#### 3.2.4 购物车功能测试

**测试步骤**：
1. 添加多个商品到购物车
2. 重复添加相同商品
3. 查看购物车页面
4. 更新商品数量
5. 删除商品

**预期结果**：
- 重复商品自动合并，数量累加
- 购物车页面正确显示所有商品
- 可以正常更新数量
- 可以正常删除商品
- 总金额计算正确

**测试结果**：✅ 通过

**关键测试点**：
- ✅ 添加商品A，数量为1
- ✅ 再次添加商品A，数量为2
- ✅ 购物车中只显示一行商品A，数量为3（1+2）

#### 3.2.5 订单创建测试

**测试步骤**：
1. 购物车中添加商品
2. 点击"去结算"
3. 填写收货信息（收货人、电话、地址、邮箱）
4. 点击"创建订单"
5. 验证订单是否创建成功

**预期结果**：
- 订单创建成功
- 跳转到订单列表页面
- 订单状态为"待支付"
- 购物车已清空
- 订单项正确保存

**测试结果**：✅ 通过

#### 3.2.6 订单支付测试

**测试步骤**：
1. 在订单列表页面点击"支付"按钮
2. 确认支付
3. 验证订单状态是否更新
4. 检查是否收到确认邮件

**预期结果**：
- 订单状态更新为"已支付"
- 支付时间正确记录
- 收到订单确认邮件（如果提供了邮箱）

**测试结果**：✅ 通过

#### 3.2.7 管理员发货测试

**测试步骤**：
1. 使用管理员账号登录
2. 进入"订单管理"页面
3. 找到状态为"已支付"的订单
4. 点击"发货"按钮
5. 验证订单状态是否更新
6. 检查是否发送发货通知邮件

**预期结果**：
- 订单状态更新为"已发货"
- 发货时间正确记录
- 用户收到发货通知邮件

**测试结果**：✅ 通过

#### 3.2.8 管理员功能测试

**测试步骤**：
1. 使用管理员账号登录
2. 访问管理后台首页
3. 查看数据概览（总订单数、销售额等）
4. 测试订单管理功能
5. 测试客户管理功能
6. 测试商品管理功能

**预期结果**：
- 数据概览正确显示统计信息
- 可以查看所有订单
- 可以查看所有客户
- 可以管理商品（增删改查）

**测试结果**：✅ 通过

#### 3.2.9 权限控制测试

**测试步骤**：
1. 使用普通用户账号登录
2. 尝试访问管理后台URL
3. 验证是否被拒绝访问

**预期结果**：
- 普通用户无法访问管理后台
- 显示"访问被拒绝"页面
- 管理员可以正常访问

**测试结果**：✅ 通过

### 3.3 测试结果说明

#### 3.3.1 功能测试结果汇总

| 测试项 | 测试结果 | 说明 |
|--------|---------|------|
| 用户注册 | ✅ 通过 | 注册功能正常，密码加密存储 |
| 用户登录 | ✅ 通过 | 登录功能正常，会话管理正常 |
| 商品浏览 | ✅ 通过 | 商品列表正常显示 |
| 购物车添加 | ✅ 通过 | 添加商品功能正常 |
| 购物车合并 | ✅ 通过 | 重复商品自动合并，数量累加 |
| 购物车更新 | ✅ 通过 | 更新数量功能正常 |
| 购物车删除 | ✅ 通过 | 删除商品功能正常 |
| 订单创建 | ✅ 通过 | 订单创建成功，购物车清空 |
| 订单支付 | ✅ 通过 | 支付功能正常，状态更新正确 |
| 订单取消 | ✅ 通过 | 取消功能正常 |
| 管理员发货 | ✅ 通过 | 发货功能正常，邮件发送成功 |
| 管理员完成订单 | ✅ 通过 | 完成订单功能正常 |
| 数据统计 | ✅ 通过 | 统计信息正确显示 |
| 权限控制 | ✅ 通过 | 角色权限控制正常 |

#### 3.3.2 测试截图说明

由于无法直接提供截图，以下是关键测试场景的说明：

1. **商品列表页面**：
   - 显示所有商品信息
   - 每个商品有"加入购物车"按钮
   - 顶部导航栏显示购物车、订单、管理后台等按钮

2. **购物车页面**：
   - 显示购物车中的所有商品
   - 每个商品可以更新数量或删除
   - 显示总金额
   - 有"去结算"按钮

3. **订单列表页面**：
   - 显示用户的所有订单
   - 每个订单显示订单号、金额、状态、时间
   - 待支付订单可以支付或取消

4. **订单详情页面**：
   - 显示订单的详细信息
   - 显示订单项列表
   - 显示收货信息
   - 可以支付或取消订单

5. **管理后台首页**：
   - 显示数据概览（总订单数、已支付订单、总销售额）
   - 显示最近订单列表
   - 有导航菜单（数据概览、订单管理、客户管理、商品管理）

6. **订单管理页面**：
   - 显示所有订单
   - 可以查看订单详情
   - 可以发货或完成订单

7. **客户管理页面**：
   - 显示所有用户列表
   - 显示用户状态（启用/停用）
   - 可以查看客户详情
   - 可以启用/停用账户

8. **商品管理页面**：
   - 显示所有商品
   - 可以添加、编辑、删除商品
   - 删除的商品不会在商品列表中显示

### 3.4 异常情况测试

#### 3.4.1 空购物车结算测试

**测试步骤**：购物车为空时点击"去结算"

**预期结果**：提示购物车为空，无法结算

**测试结果**：✅ 通过

#### 3.4.2 重复支付测试

**测试步骤**：对已支付的订单再次点击支付

**预期结果**：提示订单状态不正确，无法支付

**测试结果**：✅ 通过

#### 3.4.3 权限测试

**测试步骤**：普通用户尝试访问管理后台

**预期结果**：显示"访问被拒绝"页面

**测试结果**：✅ 通过

---

## 4. 应用部署

### 4.1 部署环境

- **服务器提供商**：腾讯云
- **服务器IP**：114.132.150.59
- **操作系统**：Ubuntu 22.04
- **访问地址**：http://114.132.150.59:8080/
- **部署方式**：Docker Compose容器化部署

### 4.2 部署详细过程

#### 4.2.1 服务器准备

1. **申请云服务器**
   - 选择腾讯云轻量应用服务器
   - 配置：2核2GB内存，40GB SSD
   - 操作系统：Ubuntu 22.04

2. **连接服务器**
   ```bash
   ssh ubuntu@114.132.150.59
   ```

3. **更新系统**
   ```bash
   sudo apt update
   sudo apt upgrade -y
   ```

#### 4.2.2 安装Docker和Docker Compose

1. **安装Docker**
   ```bash
   curl -fsSL https://get.docker.com -o get-docker.sh
   sudo sh get-docker.sh
   sudo usermod -aG docker ubuntu
   ```

2. **安装Docker Compose**
   ```bash
   sudo apt install docker-compose -y
   ```

3. **验证安装**
   ```bash
   docker --version
   docker-compose --version
   ```

#### 4.2.3 配置Docker镜像加速

由于国内网络环境，配置Docker镜像加速器：

1. **创建配置文件**
   ```bash
   sudo mkdir -p /etc/docker
   sudo tee /etc/docker/daemon.json <<-'EOF'
   {
     "registry-mirrors": [
       "https://mirror.ccs.tencentyun.com",
       "https://docker.mirrors.ustc.edu.cn"
     ]
   }
   EOF
   ```

2. **重启Docker**
   ```bash
   sudo systemctl daemon-reload
   sudo systemctl restart docker
   ```

#### 4.2.4 上传项目文件

1. **创建项目目录**
   ```bash
   sudo mkdir -p /opt/network-homework
   sudo chown ubuntu:ubuntu /opt/network-homework
   ```

2. **上传项目文件**
   - 使用SCP或WinSCP工具上传项目文件
   - 或使用Git克隆项目：
   ```bash
   cd /opt
   git clone https://github.com/WEN818/dianshang.git
   cd dianshang/network-homework
   ```

#### 4.2.5 配置数据库密码

编辑 `compose.yaml` 文件，确保数据库密码正确：
```yaml
environment:
  - MYSQL_PASSWORD=wkm20040818@
  - SPRING_DATASOURCE_PASSWORD=wkm20040818@
```

#### 4.2.6 构建和启动服务

1. **构建Docker镜像**
   ```bash
   cd /opt/network-homework
   docker-compose build
   ```

2. **启动服务**
   ```bash
   docker-compose up -d
   ```

3. **查看服务状态**
   ```bash
   docker-compose ps
   ```

4. **查看日志**
   ```bash
   docker-compose logs -f app
   ```

#### 4.2.7 配置防火墙

1. **开放8080端口**
   ```bash
   sudo ufw allow 8080/tcp
   sudo ufw reload
   ```

2. **验证端口开放**
   ```bash
   sudo ufw status
   ```

#### 4.2.8 验证部署

1. **检查容器状态**
   ```bash
   docker-compose ps
   ```
   应该看到两个容器都在运行：
   - `mysql-network-homework` - 状态：Up
   - `network-homework-app` - 状态：Up

2. **检查应用日志**
   ```bash
   docker-compose logs app | tail -50
   ```
   应该看到Spring Boot应用启动成功的日志

3. **访问应用**
   - 浏览器访问：http://114.132.150.59:8080/
   - 应该能看到登录页面

### 4.3 部署地址和测试账号

#### 4.3.1 部署地址

- **应用访问地址**：http://114.132.150.59:8080/
- **GitHub源码地址**：https://github.com/WEN818/dianshang

#### 4.3.2 测试账号

**管理员账号**：
- **用户名**：`admin`
- **密码**：`admin123`
- **权限**：可以访问管理后台，管理订单、客户、商品

**普通用户账号**：
- 可通过注册页面创建新用户
- 注册时需要提供：用户名、密码、邮箱
- 示例测试账号：
  - 用户名：`testuser`
  - 密码：`123456`
  - 邮箱：`test@example.com`

#### 4.3.3 功能测试路径

1. **用户注册**：http://114.132.150.59:8080/register/page
2. **用户登录**：http://114.132.150.59:8080/login
3. **商品列表**：http://114.132.150.59:8080/products/page
4. **购物车**：http://114.132.150.59:8080/cart/page
5. **我的订单**：http://114.132.150.59:8080/orders/page
6. **管理后台**：http://114.132.150.59:8080/admin（需要管理员权限）

### 4.4 部署注意事项

1. **数据库密码**：确保 `compose.yaml` 中的数据库密码与实际配置一致
2. **端口冲突**：确保8080端口未被占用
3. **内存要求**：建议服务器至少2GB内存
4. **网络配置**：确保服务器防火墙开放8080端口
5. **邮件配置**：如需使用邮件功能，需要配置正确的SMTP信息

### 4.5 维护和更新

#### 4.5.1 更新代码

```bash
cd /opt/network-homework
git pull origin main
docker-compose down
docker-compose up -d --build
```

#### 4.5.2 查看日志

```bash
# 查看应用日志
docker-compose logs -f app

# 查看数据库日志
docker-compose logs -f mysql
```

#### 4.5.3 重启服务

```bash
docker-compose restart app
```

#### 4.5.4 停止服务

```bash
docker-compose down
```

---

## 5. 总结

### 5.1 项目完成情况

本实验成功实现了一个功能完整的中小型电商系统，包括：

✅ **用户管理**：注册、登录、注销账户  
✅ **商品管理**：商品增删改查、软删除  
✅ **购物车功能**：添加、更新、删除、自动合并重复商品  
✅ **订单管理**：创建、支付、取消、发货、完成  
✅ **管理员功能**：数据统计、订单管理、客户管理、商品管理  
✅ **邮件通知**：订单确认、发货通知  
✅ **权限控制**：基于角色的访问控制  
✅ **容器化部署**：Docker Compose一键部署  

### 5.2 技术亮点

1. **架构设计**：采用经典三层架构，代码结构清晰
2. **安全机制**：Spring Security实现完善的认证和授权
3. **数据完整性**：使用事务保证数据一致性
4. **用户体验**：前端界面友好，操作流畅
5. **可维护性**：代码注释完善，易于维护和扩展

### 5.3 遇到的问题和解决方案

1. **问题**：购物车重复商品未合并  
   **解决**：在 `CartService.addToCart` 中添加了商品存在性检查，实现自动合并

2. **问题**：订单支付和发货按钮404错误  
   **解决**：修复了前端JavaScript的API路径，使用正确的REST API端点

3. **问题**：Docker构建时网络问题  
   **解决**：配置了Docker镜像加速器，使用国内镜像源

4. **问题**：邮件发送失败  
   **解决**：配置了正确的SMTP信息，使用QQ邮箱服务

### 5.4 未来改进方向

1. 添加商品分类和搜索功能
2. 实现支付接口集成（支付宝、微信）
3. 添加商品评价功能
4. 实现数据分析和报表功能
5. 添加移动端适配
6. 优化数据库查询性能
7. 添加缓存机制（Redis）

---

**实验完成日期**：2024年12月20日  
**学号**：202230443019  
**姓名**：温恺曼  
**GitHub**：https://github.com/WEN818/dianshang

